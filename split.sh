#!/usr/bin/env bash
set -euo pipefail

# Usage: split_and_encode.sh <zip_file> <max_size> [output_dir]
# Example:
#   split_and_encode.sh my_archive.zip 95m ./out

if [[ $# -lt 2 || $# -gt 3 ]]; then
  echo "Usage: $0 <zip_file> <max_size> [output_dir]" >&2
  exit 1
fi

ZIP_PATH="$1"
CHUNK_SIZE="$2"
OUT_DIR="${3:-.}"

if [[ ! -f "$ZIP_PATH" ]]; then
  echo "Error: '$ZIP_PATH' not found." >&2
  exit 1
fi

mkdir -p "$OUT_DIR"

ZIP_BASE="$(basename "$ZIP_PATH")"
PREFIX="$OUT_DIR/$ZIP_BASE.part"

# Split into parts (numeric suffixes)
split -b "$CHUNK_SIZE" -a 4 -d -- "$ZIP_PATH" "$PREFIX"

# Optional SHA256 manifest
if command -v shasum >/dev/null 2>&1; then
  shasum -a 256 -- "$ZIP_PATH" > "$OUT_DIR/$ZIP_BASE.sha256"
elif command -v sha256sum >/dev/null 2>&1; then
  sha256sum -- "$ZIP_PATH" > "$OUT_DIR/$ZIP_BASE.sha256"
fi

# Encode each chunk â†’ .txt
encode_one() {
  local bin="$1"
  local txt="${bin}.txt"
  base64 < "$bin" | tr -d '\n' > "$txt"
  printf '\n' >> "$txt"
}

if sort -V </dev/null >/dev/null 2>&1; then
  for part in $(ls -1 "$PREFIX"* | sort -V); do
    encode_one "$part"
  done
else
  ls -1 "$PREFIX"* | awk '
    match($0, /.*\.part([0-9]+)$/, m){print m[1], $0}
  ' | sort -n | awk '{print $2}' | while read -r part; do
    encode_one "$part"
  done
fi

cat > "$OUT_DIR/README_split.txt" <<EOF
Generated by split_and_encode.sh
Original file : $ZIP_BASE
Chunk prefix  : $(basename "$PREFIX")
TXT files     : *.partNNNN.txt (order matters)
Optional hash : $ZIP_BASE.sha256
EOF

echo "Done. Encoded parts are in $OUT_DIR"
